\documentclass{article}
\usepackage{mathpartir}
\usepackage{graphicx}
\usepackage{cancel}
\usepackage{amssymb}
\usepackage{amsmath}

\newcommand{\namedrule}[3]{\inferrule{#1}{#2}\ \text{({\sc #3})}}
\newcommand{\rulename}[1]{\textsc{#1}}
\newcommand{\lit}[1]{\textsf{#1}}
\newcommand{\FV}{\mathit{FV}}
\newcommand{\dom}{\mathop{\mathrm{dom}}}
\newcommand{\var}[1]{\mathit{#1}}

\newcommand{\decl}[2]{#1{:}#2}
\newcommand{\rdecl}[2]{#1\,{:}\,#2}
\newcommand{\rbind}[2]{#1 = #2}
\newcommand{\bind}[2]{#1.\, #2}
\newcommand{\tbind}[3]{\bind{\decl{#1}{#2}}{#3}}

\newcommand{\step}[2]{#1 \longrightarrow #2}
\newcommand{\stepstar}[2]{#1 \longrightarrow^* #2}

\newcommand{\etrue}{\lit{true}}
\newcommand{\efalse}{\lit{false}}
\newcommand{\eif}[4]{\lit{if}_{#1}\,#2\,\lit{then}\,#3\,\lit{else}\,#4}
\newcommand{\enot}{\lit{not}}
\newcommand{\eand}{\lit{and}}
\newcommand{\eor}{\lit{or}}
\newcommand{\ezero}{\lit{zero}}
\newcommand{\esucc}[1]{\lit{succ}\,#1}
\newcommand{\enil}{\lit{nil}}
\newcommand{\econs}{\lit{cons}}
\newcommand{\eleaf}{\lit{leaf}}
\newcommand{\enode}{\lit{node}}
\newcommand{\erec}[5]{\kwd{rec}(#1,\, #2,\, \tbind{#3}{#4}{#5})}
\newcommand{\eapp}[2]{#1\ #2}
\newcommand{\eApp}[2]{#1\,[#2]}
\newcommand{\eunit}{\langle \rangle}
\newcommand{\epair}[2]{\langle #1, #2 \rangle}
\newcommand{\efst}[1]{\lit{fst}\,#1}
\newcommand{\esnd}[1]{\lit{snd}\,#1}
\newcommand{\einl}[1]{\lit{inl}\,#1}
\newcommand{\einr}[1]{\lit{inr}\,#1}
\newcommand{\ecase}[5]{\lit{case}\,#1\,\lit{of}\,\einl{#2}\Rightarrow\,#3
  \mid\,\einr{#4}\Rightarrow\,#5}
\newcommand{\epackspaced}[5]{\lit{pack}\,\langle #1,#2 \rangle #3\lit{as}\:{\texist #4 #5}}
\newcommand{\epack}[4]{\epackspaced #1 #2 {\,} #4}
\newcommand{\eunpack}[4]{\lit{unpack}\,\langle #2,#3 \rangle = #1\:\lit{in}\:#4}
%\newcommand{\elet}[3]{\lit{let}\,#1 = #2\,\lit{in}\,#3}

\newcommand{\eproj}[2]{#1.#2}
\newcommand{\eunroll}[1]{\kwd{unroll}\,#1}
\newcommand{\eannot}[2]{(#1 : #2)}
%\newcommand{\elam}[2]{\lambda \bind{#1}{#2}}
\newcommand{\elam}[3]{\lambda \tbind{#1}{#2}{#3}}
\newcommand{\eLam}[2]{\Lambda \bind{#1}{#2}}
\newcommand{\erecord}[1]{\{\, #1 \,\}}
\newcommand{\einj}[2]{[\, \rbind{#1}{#2} \,]}
%\newcommand{\ecase}[4]{\kwd{case}\,#1\,\{\,\einj{#2}{#3} \Rightarrow #4\,\}}
\newcommand{\enatcase}[4]{\kwd{natcase}\,#1\,\kwd{of}\,\{\,\lzero \Rightarrow #2,%
                                                 \lsucc\,#3 \Rightarrow #4\,\}}
\newcommand{\elistcase}[6]{\kwd{listcase}_#1\,#2\,%
                            \{\,\lnil \Rightarrow #3,%
                                \lcons(#4, #5) \Rightarrow #6\,\}}
\newcommand{\eroll}[1]{\lit{roll}\,#1}
%\newcommand{\efix}[2]{\kwd{fix}\,\bind{#1}{#2}}

\newcommand{\efix}[3]{\kwd{fix}\,\tbind{#1}{#2}{#3}}
\newcommand{\etroll}[2]{\lit{roll}_{#1}\,{#2}}
\newcommand{\etinj}[3]{\einj{#1}{#2}_{#3}}
\newcommand{\etcase}[3]{\kwd{case}_{#1}\,#2\,\{\,#3\,\}}
\newcommand{\casecase}[3]{\einj{#1}{#2} \Rightarrow #3}
\newcommand{\etcasen}[5]{\kwd{case}_{#1}\,#2\,\{\,\casecase{#3}{#4}{#5}\,\}}

% \newcommand{\steval}[2]{#1 > #2}
% \newcommand{\stret}[2]{#1 < #2}
% \newcommand{\stfail}[2]{#1 < \lit{fail}}

\newcommand{\tbool}{\lit{bool}}
\newcommand{\tnat}{\lit{nat}}
\newcommand{\tstr}{\lit{string}}
\newcommand{\tint}{\lit{int}}
\newcommand{\tnatlist}{\lit{natlist}}
\newcommand{\tlist}[1]{#1\,\lit{list}}
\newcommand{\ttree}[1]{#1\,\lit{tree}}
\newcommand{\tarrow}[2]{#1 \rightarrow #2}
\newcommand{\tunit}{\lit{unit}}
\newcommand{\tprod}[2]{#1 \times #2}
\newcommand{\tsum}[2]{#1 + #2}
\newcommand{\trecord}[1]{\{\, #1 \,\}}
\newcommand{\tvariant}[1]{[\, #1 \,]}
\newcommand{\tmu}[2]{\mu \bind{#1}{#2}}
\newcommand{\tforall}[2]{\forall \bind{#1}{#2}}
\newcommand{\texist}[2]{\exists \bind{#1}{#2}}


\newcommand{\cclam}[3]{\lambda \bind{[{#1}]({#2})}{#3}}

\begin{document}
\section{Interpretation of rules}
\[
\inferrule{ \Gamma_1 \vdash X_1~{\tt type} ~...~ \Gamma_i \vdash X_i~{\tt type}}{\Gamma \vdash c(X_1,...,X_i)~{\tt type}}
\equiv
{\tt term\_rule}~[\Gamma_1 : {\tt Ctx},...,\Gamma_i : {\tt Ctx},X_1 :{\tt Ty}~ \Gamma_1,...,X_i:{\tt Ty}~ \Gamma_i]~({\tt Ty}~ \Gamma) \]


\[\begin{array}{l}
\inferrule{ \Gamma_1 \vdash X_1~{\tt type} ~...~ \Gamma_i \vdash X_i~{\tt type}
 \quad \Gamma'_1 \vdash x_1 :\tau'_1 ~...~ \Gamma'_j \vdash x_j :\tau'_j}{\Gamma \vdash c(X_1,...,X_i,x_1,...,x_j) : \tau}
\\\equiv
{\tt term\_rule}~[\Gamma_1 : {\tt Ctx},...,\Gamma_i : {\tt Ctx},{\tt Ty}~ \Gamma_1,...,{\tt Ty}~ \Gamma_i,{\tt El}~ \Gamma'_1~\tau_1,...,{\tt El}~ \Gamma'_i~\tau_i]~({\tt El}~ \Gamma~ \tau)
\end{array}\]
\section{STLC Rules}
\begin{align*}
\inferrule{\Gamma,x:\tau \vdash e : \tau'}
{\Gamma \vdash \elam x \tau e :\tau \to \tau'}
\quad
\inferrule{\Gamma \vdash e : \tau\to \tau' \quad \Gamma \vdash e' : \tau}
{\Gamma \vdash e~e' :\tau'}
\quad
\inferrule{\Gamma,x:\tau \vdash e : \tau' \quad \Gamma \vdash e' : \tau}
{\Gamma \vdash (\elam x \tau e)~e' \sqsupseteq \sqsubseteq e[e'/x] :\tau'}
\end{align*}
\section{CC Rules}
\begin{align*}
\inferrule{X_1...X_n,x_1:\tau_1...x_m:\tau_m \vdash e : \tau'}
{\Gamma \vdash \cclam {X_1...X_n} {x_1:\tau_1...x_m:\tau_m} e 
:\tforall {X_1...X_n}{(\tau_1...\tau_m) \to \tau'}}
\quad
\\\inferrule{\Gamma \vdash e : \tforall {X_1...X_n}{(\tau_1...\tau_n) \to \tau'} 
\quad \Gamma \vdash e'_1  : \tau ~...~ \Gamma \vdash e'_m  : \tau
\quad \Gamma \vdash \sigma_i ~{\tt type} ~...~ \Gamma \vdash \sigma_n ~{\tt type}}
{\Gamma \vdash e~[\sigma_1...\sigma_n]~(e'_1...e'_m) :\tau'}
\\\quad
\inferrule{X_1...X_n,x_1:\tau_1...x_m:\tau_n \vdash e : \tau' 
\quad \Gamma \vdash e'_1  : \tau ~...~ \Gamma \vdash e'_m  : \tau
\quad \Gamma \vdash \sigma_i ~{\tt type} ~...~ \Gamma \vdash \sigma_n ~{\tt type}}
{\Gamma \vdash (\cclam {X_1...X_n} {x_1:\tau_1...x_m:\tau_m} e)~[\sigma_1...\sigma_n]~(e'_1...e'_m) 
	 \sqsupseteq \sqsubseteq e[e'_1/x_1,...,e'_m/x_m] :\tau'}
\end{align*}
\section{Compiler}
We define our compiler as follows:
\\TODO:need separate delta in judgments to make separate Xs work right?otherwise, need to mix x and Xs in CC,products
\[\begin{array}{lcl}
(\Gamma \vdash \tau \to \tau)^+ &=& (\Gamma)^+ \vdash \texist Y {\tprod{(\tforall {X_1...X_n}{(Y, \tau_1...\tau_m) \to \tau'})}Y}\\
(\Gamma \vdash \elam x \tau e : \tau \to \tau')^+ &=& 
	\epackspaced {envty(\Gamma^+)}
	{\epair {\cclam {?} {?} {e^+}}{mkenv(\Gamma^+)}}{\\&&}
	Y {\tprod{(\tforall {}{(Y, \tau^+) \to \tau'^+})}Y}\\
\\
mkenv(\cdot) &=& \eunit
\end{array}\]
\end{document}







