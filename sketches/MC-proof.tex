\documentclass{article}
\usepackage{mathpartir}
\usepackage{graphicx}
\usepackage{cancel}
\usepackage{amssymb}
\usepackage{amsmath}

\newcommand{\namedrule}[3]{\inferrule{#1}{#2}\ \text{({\sc #3})}}
\newcommand{\rulename}[1]{\textsc{#1}}
\newcommand{\lit}[1]{\textsf{#1}}
\newcommand{\FV}{\mathit{FV}}
\newcommand{\dom}{\mathop{\mathrm{dom}}}
\newcommand{\var}[1]{\mathit{#1}}

\newcommand{\decl}[2]{#1{:}#2}
\newcommand{\rdecl}[2]{#1\,{:}\,#2}
\newcommand{\rbind}[2]{#1 = #2}
\newcommand{\bind}[2]{#1.\, #2}
\newcommand{\tbind}[3]{\bind{\decl{#1}{#2}}{#3}}

\newcommand{\step}[2]{#1 \longrightarrow #2}
\newcommand{\stepstar}[2]{#1 \longrightarrow^* #2}

\newcommand{\etrue}{\lit{true}}
\newcommand{\efalse}{\lit{false}}
\newcommand{\eif}[4]{\lit{if}_{#1}\,#2\,\lit{then}\,#3\,\lit{else}\,#4}
\newcommand{\enot}{\lit{not}}
\newcommand{\eand}{\lit{and}}
\newcommand{\eor}{\lit{or}}
\newcommand{\ezero}{\lit{zero}}
\newcommand{\esucc}[1]{\lit{succ}\,#1}
\newcommand{\enil}{\lit{nil}}
\newcommand{\econs}{\lit{cons}}
\newcommand{\eleaf}{\lit{leaf}}
\newcommand{\enode}{\lit{node}}
\newcommand{\erec}[5]{\kwd{rec}(#1,\, #2,\, \tbind{#3}{#4}{#5})}
\newcommand{\eapp}[2]{#1\ #2}
\newcommand{\eApp}[2]{#1\,[#2]}
\newcommand{\eunit}{\langle \rangle}
\newcommand{\epair}[2]{\langle #1, #2 \rangle}
\newcommand{\efst}[1]{\lit{fst}\,#1}
\newcommand{\esnd}[1]{\lit{snd}\,#1}
\newcommand{\einl}[1]{\lit{inl}\,#1}
\newcommand{\einr}[1]{\lit{inr}\,#1}
\newcommand{\ecase}[5]{\lit{case}\,#1\,\lit{of}\,\einl{#2}\Rightarrow\,#3
  \mid\,\einr{#4}\Rightarrow\,#5}
\newcommand{\epackspaced}[5]{\lit{pack}\,\langle #1,#2 \rangle #3\lit{as}\:{\texist #4 #5}}
\newcommand{\epack}[4]{\epackspaced #1 #2 {\,} #4}
\newcommand{\eunpack}[4]{\lit{unpack}\,\langle #2,#3 \rangle = #1\:\lit{in}\:#4}
%\newcommand{\elet}[3]{\lit{let}\,#1 = #2\,\lit{in}\,#3}

\newcommand{\eproj}[2]{#1.#2}
\newcommand{\eunroll}[1]{\kwd{unroll}\,#1}
\newcommand{\eannot}[2]{(#1 : #2)}
%\newcommand{\elam}[2]{\lambda \bind{#1}{#2}}
\newcommand{\elam}[3]{\lambda \tbind{#1}{#2}{#3}}
\newcommand{\eLam}[2]{\Lambda \bind{#1}{#2}}
\newcommand{\erecord}[1]{\{\, #1 \,\}}
\newcommand{\einj}[2]{[\, \rbind{#1}{#2} \,]}
%\newcommand{\ecase}[4]{\kwd{case}\,#1\,\{\,\einj{#2}{#3} \Rightarrow #4\,\}}
\newcommand{\enatcase}[4]{\kwd{natcase}\,#1\,\kwd{of}\,\{\,\lzero \Rightarrow #2,%
                                                 \lsucc\,#3 \Rightarrow #4\,\}}
\newcommand{\elistcase}[6]{\kwd{listcase}_#1\,#2\,%
                            \{\,\lnil \Rightarrow #3,%
                                \lcons(#4, #5) \Rightarrow #6\,\}}
\newcommand{\eroll}[1]{\lit{roll}\,#1}
%\newcommand{\efix}[2]{\kwd{fix}\,\bind{#1}{#2}}

\newcommand{\efix}[3]{\kwd{fix}\,\tbind{#1}{#2}{#3}}
\newcommand{\etroll}[2]{\lit{roll}_{#1}\,{#2}}
\newcommand{\etinj}[3]{\einj{#1}{#2}_{#3}}
\newcommand{\etcase}[3]{\kwd{case}_{#1}\,#2\,\{\,#3\,\}}
\newcommand{\casecase}[3]{\einj{#1}{#2} \Rightarrow #3}
\newcommand{\etcasen}[5]{\kwd{case}_{#1}\,#2\,\{\,\casecase{#3}{#4}{#5}\,\}}

% \newcommand{\steval}[2]{#1 > #2}
% \newcommand{\stret}[2]{#1 < #2}
% \newcommand{\stfail}[2]{#1 < \lit{fail}}

\newcommand{\tbool}{\lit{bool}}
\newcommand{\tnat}{\lit{nat}}
\newcommand{\tstr}{\lit{string}}
\newcommand{\tint}{\lit{int}}
\newcommand{\tnatlist}{\lit{natlist}}
\newcommand{\tlist}[1]{#1\,\lit{list}}
\newcommand{\ttree}[1]{#1\,\lit{tree}}
\newcommand{\tarrow}[2]{#1 \rightarrow #2}
\newcommand{\tunit}{\lit{unit}}
\newcommand{\tprod}[2]{#1 \times #2}
\newcommand{\tsum}[2]{#1 + #2}
\newcommand{\trecord}[1]{\{\, #1 \,\}}
\newcommand{\tvariant}[1]{[\, #1 \,]}
\newcommand{\tmu}[2]{\mu \bind{#1}{#2}}
\newcommand{\tforall}[2]{\forall \bind{#1}{#2}}
\newcommand{\texist}[2]{\exists \bind{#1}{#2}}


\newcommand{\ulam}[2]{\lambda \bind{{#1}}{#2}}

\newtheorem{theorem}{Theorem}

\begin{document}

\section{Identity Compilers}

\begin{theorem}[Identity compilers preserve semantics]
Let $L_1 {++} S$, $L_2 {++} S$, and $T$ be well-formed languages
such that $L_1$ is contained in $T$.
Let $c$ be a semantics-preserving compiler from $L_2{++}L$ to $T$.
Then $\texttt{repeat id (size }L_1\texttt{) } {++}~ c$ is a
semantics preserving compiler from $L_1 {++} L_2 {++} L$ to $T$.
\end{theorem}

Proof sketch:
By induction on $L$.
We must consider each kind of rule.
We show here the case for term relatedness:

We have the following on the head of $L$:
\texttt{term\_le c e1 e2 t}.
It then suffices to derive
$\inferrule{\texttt{id c}}{\texttt{id e1} \sqsupseteq \texttt{id e2} : \texttt{id t}}$
in the target.
We may conclude since there is exactly such a rule, since the target contains $L$.

Note: strictly speaking, we need the indices of the constructors to line up if we want to use the identity function. The more general version of this theorem performs a constant shift on constructors in $L$.

\section{Interpretation of rules}
\[
\inferrule{ \Gamma_1 \vdash X_1~{\tt type} ~...~ \Gamma_i \vdash X_i~{\tt type}}{\Gamma \vdash c(X_1,...,X_i)~{\tt type}}
\equiv
{\tt term\_rule}~[\Gamma_1 : {\tt Ctx},...,\Gamma_i : {\tt Ctx},X_1 :{\tt Ty}~ \Gamma_1,...,X_i:{\tt Ty}~ \Gamma_i]~({\tt Ty}~ \Gamma) \]


\[\begin{array}{l}
\inferrule{ \Gamma_1 \vdash X_1~{\tt type} ~...~ \Gamma_i \vdash X_i~{\tt type}
 \quad \Gamma'_1 \vdash x_1 :\tau'_1 ~...~ \Gamma'_j \vdash x_j :\tau'_j}{\Gamma \vdash c(X_1,...,X_i,x_1,...,x_j) : \tau}
\\\equiv
{\tt term\_rule}~[\Gamma_1 : {\tt Ctx},...,\Gamma_i : {\tt Ctx},{\tt Ty}~ \Gamma_1,...,{\tt Ty}~ \Gamma_i,{\tt El}~ \Gamma'_1~\tau_1,...,{\tt El}~ \Gamma'_i~\tau_i]~({\tt El}~ \Gamma~ \tau)
\end{array}\]
\section{STLC Rules}
\begin{align*}
\inferrule{\Gamma,x:\tau \vdash e : \tau'}
{\Gamma \vdash \elam x \tau e :\tau \to \tau'}
\quad
\inferrule{\Gamma \vdash e : \tau\to \tau' \quad \Gamma \vdash e' : \tau}
{\Gamma \vdash e~e' :\tau'}
\quad
\inferrule{\Gamma,x:\tau \vdash e : \tau' \quad \Gamma \vdash e' : \tau}
{\Gamma \vdash (\elam x \tau e)~e' \sqsupseteq \sqsubseteq e[e'/x] :\tau'}
\end{align*}


\section{Product Type Rules}
\begin{align*}
\inferrule{\Gamma \vdash e_1 : \tau_1 \quad \Gamma \vdash e_2 : \tau_2}
{\Gamma \vdash \epair {e_1} {e_2} :\tau_1 \times \tau_2}
\quad
\inferrule{\Gamma \vdash e : \tau_1 \times \tau_2}
{\Gamma \vdash e.1 :\tau_1}
\quad
\inferrule{\Gamma \vdash e : \tau_1 \times \tau_2}
{\Gamma \vdash e.2 :\tau_2}
\\
\inferrule{\Gamma \vdash e_1 : \tau_1 \quad \Gamma \vdash e_2 : \tau_2}
{\Gamma \vdash \epair {e_1} {e_2} .1 \sqsupseteq \sqsubseteq e_1:\tau_1}
\quad
\inferrule{\Gamma \vdash e_1 : \tau_1 \quad \Gamma \vdash e_2 : \tau_2}
{\Gamma \vdash \epair {e_1} {e_2} .2 \sqsupseteq \sqsubseteq e_2:\tau_2}
\end{align*}

\section{CC Rules}
TODO: 2 options: can close over delta or leave it open. Need tyvars for the former, so I'll avoid it for expedience.
\begin{align*}
\inferrule{\Delta;x:\tau \vdash e : \tau'}
{\Delta; \Gamma \vdash \elam x\tau e 
:\tau \to \tau'}
\quad
\inferrule{\Delta;\Gamma \vdash e : {\tau \to \tau'} 
\quad \Delta;\Gamma \vdash e'  : \tau}
{\Delta;\Gamma \vdash e~e' :\tau'}
\quad
\inferrule{\Delta;x:\tau\vdash e : \tau' 
\quad \Delta;\Gamma \vdash e'  : \tau}
{\Delta; \Gamma \vdash (\elam x\tau e)~e' 
	 \sqsupseteq \sqsubseteq e[e'/x] :\tau'}
\end{align*}
We additionally add the standard rules for existentials, pairs, and the unit type (TODO: write out).
\section{Closure Conversion}
We define our compiler as follows:
\[\begin{array}{lcl}
(\tau \to \tau')^+ &=&  \texist Y {\tprod{({\tprod Y {\tau^+} \to \tau'^+})}Y}\\
(\Gamma \vdash \elam x \tau e : \tau \to \tau')^+ &=& 
	\epackspaced {envty(\Gamma^+)}
	{\epair {\elam y {\tprod{envty(\Gamma^+)} {\tau^+}} {e^+[y.i/i]}}{mkenv(size(\Gamma^+))}}{\\&&}
	Y {\tprod{({(Y, \tau^+) \to \tau'^+})}Y}\\
(e~e')^+ &=& \eunpack {e^+} Y p {p.1~ \epair{p.2}{e'^+}}\\
\\
mkenv(0) &=& \eunit\\
mkenv(n +1) &=& \epair {mkenv(n)} n\\
\\ 
envty(\cdot) &=& \tunit\\
envty(\Gamma, \tau) &=& \tprod {envty(\Gamma)} {\tau}
\end{array}\]

\subsection{Judgment-preserving compilation}
We proceed rule-by-rule. Consider an arbitrary substitution satisfying the premises of each rule in the target.
It suffices to show that the translation is well-typed.
\begin{itemize}
\item Function type:
Consider arbitrary closed, well-formed $\tau,\tau'$ in the target language.
We then have the following derivation:
\[
\inferrule{\inferrule{
\inferrule{\inferrule{\inferrule{Y \in Y}{Y \vdash Y}\quad Y \vdash \tau}{Y \vdash \tprod Y\tau}\quad{Y \vdash \tau'}}
{Y \vdash {({\tprod Y \tau \to \tau'})}}
	 \quad \inferrule{Y \in Y}{Y \vdash Y}}
{Y \vdash \tprod{({\tprod Y \tau \to \tau'})}Y}}
{\cdot \vdash \texist Y {\tprod{({\tprod Y \tau \to \tau'})}Y}}
\]
\item Application:
Let $\tau_f = \tprod{(\tprod Y \tau\to \tau')}Y$.
\[
\inferrule{
	\cdot; \Gamma \vdash e : \texist Y {\tau_f}
	\quad \inferrule{\inferrule{\inferrule{ }{Y;\Gamma,p : \tau_f\vdash {p} : \tau_f}}
				{Y;\Gamma,p : \tau_f\vdash {p.1} : {\tprod Y \tau \to \tau'}}
				\quad \inferrule{\inferrule{ }{Y;\Gamma,p : \tau_f\vdash {p} : \tau_f}}{Y;\Gamma,p : \tau_f\vdash {p.2} : Y}
				\quad \inferrule{Y;\Gamma\vdash {e'} : \tau}{Y;\Gamma,p : \tau_f\vdash {e'} : \tau}}
		{Y;\Gamma,p : \tau_f\vdash {p.1~ (p.2,e')} : \tau'}
	\quad \cdot \vdash \tau'}
{\cdot;\Gamma \vdash \eunpack {e} Y p {p.1~ (p.2,e')} : \tau'}
\] 
\item Beta-reduction: We need to show the following:
\[
\inferrule{\Gamma,x:\tau \vdash e : \tau' \quad \Gamma \vdash e' : \tau}
{\begin{array}{lll}\Gamma \vdash &\eunpack {&\epackspaced {envty(\Gamma)}
	{\epair {\elam y {envty(\Gamma) \times\tau} {e[y.i/i]}}{mkenv(size(\Gamma))}}{\\&&}
	Y {\tprod{({\tprod Y \tau \to \tau'})}Y}\\&} Y p {p.1~ (p.2,e')}
\\&\sqsupseteq \sqsubseteq e[e'/x] :\tau'
\end{array}}\]
We proceed by these steps:
\[\begin{array}{rl}
&\begin{array}{lll}\eunpack {&\epackspaced {envty(\Gamma)}
	{\epair {\elam y{ envty(\Gamma), x : \tau} {e[y.i/i]}}{mkenv(size(\Gamma))}}{\\&}
	Y {\tprod{({\tprod Y \tau \to \tau'})}Y}\\} Y p {p.1~ (p.2,e')}
\end{array}\\
\sqsupseteq \sqsubseteq& 
(p.1~ (p.2,e'))[envty(\Gamma)/Y, \epair {\elam y {envty(\Gamma) \times \tau} {e[y.i/i]}}{mkenv(size(\Gamma))}/p]\\
\sqsupseteq \sqsubseteq& 
((\elam y {envty(\Gamma) \times \tau} {e[y.i/i]})~ 
	(mkenv(size(\Gamma)),e'))\\
\sqsupseteq \sqsubseteq& 
	e[y.i/i][\epair{mkenv(size(\Gamma))} {e'}/y]\\
\sqsupseteq \sqsubseteq& 
	e[e'/x]\\
\end{array}\]
\end{itemize}

\section{Adding source-language products}
Let STLC$^\times$ be STLC plus the product language.
By our identity compilers theorem, we have a semantics preserving compiler from STLC$^\times$ to CC.

Note: there is one caveat here: $\Delta$.
To use this result, we would have to add $\Delta$s to every rule in STLC$^\times$.
However, I conjecture that this can be done with a general purpose lemma (one that does not mention STLC or products).
 

\section{Untyped Lambda Calculus}

\begin{align*}
\inferrule{\Gamma,x:{\tt Dyn} \vdash e : {\tt Dyn}}
{\Gamma \vdash \ulam x e : {\tt Dyn}}
\quad
\inferrule{\Gamma \vdash e : {\tt Dyn} \quad \Gamma \vdash e' : {\tt Dyn}}
{\Gamma \vdash e~e' :{\tt Dyn}}
\quad
\inferrule{\Gamma,x:{\tt Dyn} \vdash e : {\tt Dyn} \quad \Gamma \vdash e' : {\tt Dyn}}
{\Gamma \vdash (\ulam x e)~e' \sqsupseteq \sqsubseteq e[e'/x] :{\tt Dyn}}
\end{align*}

\section{CPS}

\subsection{Call-by-value}

Note that for call-by-value, we have to call the continuation on variables
and dually, evaluate expressions before substitution.
This means we cannot take advantage of the identity compiler for substitutions.

We define our compiler as follows:
\[\begin{array}{lcl}
(\Gamma \vdash x)^+ &=& \Gamma,k : {\tt Dyn} \vdash k~ x\\
(\Gamma \vdash e[e'/x])^+ &=& \Gamma,k : {\tt Dyn} \vdash e'^+~[\ulam r {(e^+[r/x])}/k]\\
(\tau \to \tau')^+ &=&  {\tt Dyn}\\
(\Gamma\vdash \elam x \tau e)^+ &=& 
	\Gamma,k : {\tt Dyn} \vdash {k~\ulam x {\ulam k {e^+}}}\\
(\Gamma\vdash e~e')^+ &=& 
	\Gamma,k : {\tt Dyn} \vdash{e^+[\ulam f {(e'^+[\ulam r {(f~r~k)}/k])}/k]}
\end{array}\]

All resulting terms are well-scoped and so well-typed in the dynamic target.

We demonstrate the substitution case as the representative example:

\[
\inferrule
{\Gamma,k : {\tt Dyn} \vdash e':{\tt Dyn} \quad 
	\inferrule{\inferrule{\Gamma,k : {\tt Dyn},x:{\tt Dyn} \vdash {e}  : {\tt Dyn} \quad
				\inferrule{r\in \Gamma,k : {\tt Dyn},r:{\tt Dyn}}{\Gamma,k : {\tt Dyn},r:{\tt Dyn} \vdash {r}  : {\tt Dyn}}}
			{\Gamma,k : {\tt Dyn},r:{\tt Dyn} \vdash {(e[r/x])}  : {\tt Dyn}}}
	{\Gamma,k : {\tt Dyn} \vdash \ulam r {(e[r/x])}  : {\tt Dyn}}}
{\Gamma,k : {\tt Dyn} \vdash e'~[\ulam r {(e[r/x])}/k]  : {\tt Dyn}}
\]

It remains to show that beta equivalence holds:

\[\inferrule{\Gamma,x:{\tt Dyn},k:{\tt Dyn}\vdash e : {\tt Dyn} 
\quad \Gamma,k:{\tt Dyn} \vdash e'  : {\tt Dyn}}
{\Gamma,k:{\tt Dyn} \vdash (k~\ulam x {\ulam k {e}})[\ulam f {(e'[\ulam r {(f~r~k)}/k])}/k]
	 \sqsupseteq \sqsubseteq e'~[\ulam r {(e[r/x])}/k] :{\tt Dyn}}\]
We use the following relations:

\[\begin{array}{rl}
&(k~\ulam x {\ulam k {e}})[\ulam f {(e'[\ulam r {(f~r~k)}/k])}/k]\\
\sqsupseteq \sqsubseteq& (\ulam f {(e'[\ulam r {(f~r~k)}/k])})~\ulam x {\ulam k {e}}\\
\sqsupseteq \sqsubseteq& {(e'[\ulam r {((\ulam x {\ulam k {e}})~r~k)}/k])}\\
\sqsupseteq \sqsubseteq& {(e'[\ulam r {((\ulam k {e[r/x]})~k)}/k])}\\
\sqsupseteq \sqsubseteq& {(e'[\ulam r {({e[r/x, k/k]})}/k])}\\
\sqsupseteq \sqsubseteq& {(e'[\ulam r {({e[r/x]})}/k])}
\end{array}\]


\subsection{Call-by-name}
We define our compiler as follows:
\[\begin{array}{lcl}
(\tau \to \tau')^+ &=&  {\tt Dyn}\\
(\elam x \tau e)^+ &=& \ulam k{k~\ulam x {e^+}}\\
(e~e')^+ &=& \ulam k {e^+~(\ulam f {f~e'^+~ k})}
\end{array}\]

All resulting terms are well-scoped and so well-typed in the dynamic target.

It remains to show that beta equivalence holds:

\[\inferrule{\Gamma,x:{\tt Dyn}\vdash e : {\tt Dyn} 
\quad \Gamma\vdash e'  : {\tt Dyn}}
{\Gamma \vdash \ulam k {(\ulam k{k~\ulam x {e}})~(\ulam f {f~e'~ k})}
	 \sqsupseteq \sqsubseteq e[e'/x] :{\tt Dyn}}\]
We want to use the following relations:

\[\begin{array}{rl}
&\ulam k {(\ulam k{k~\ulam x {e}})~(\ulam f {f~e'~ k})}\\
\sqsupseteq \sqsubseteq& \ulam k {(\ulam f {f~e'~ k})~\ulam x {e}}\\
\sqsupseteq \sqsubseteq& \ulam k {(\ulam x {e})~e'~ k}\\
\sqsupseteq \sqsubseteq& \ulam k {(e[e'/x])~ k}\\
\not\sqsupseteq \not \sqsubseteq& e[e'/x]
\end{array}\]

However, since we do not have $\eta$ rules, we cannot complete this proof.

\pagebreak

\section{Order of Evaluation}

To enforce call-by-value evaluation on pure languages like STLC and the product construct,
we need to restrict their relations to the case where e.g. the argument to a function is a value.
Thus, we need a notion of value.
We add the following sort: ${\bf \Gamma} : Ctx, {\bf \tau} : Ty({\bf \Gamma}) \vdash Val({\bf \Gamma},{\bf \tau})~\text{sort}$. In addition, since values are usually regarded as a special case of expressions, we add the following relation:
\[\inferrule{\vdash{\bf \Gamma}\quad{\bf \Gamma}\vdash {\bf \tau}}
{Val({\bf \Gamma},{\bf \tau}) \sqsupseteq Exp({\bf \Gamma},{\bf \tau})}
\]
This effectively declares the well-typed value judgment as a subset of the well-typed expression judgment.
We will use the notation $\Gamma \vdash_v e : \tau$ to mean $e : Val(\Gamma,\tau)$.

A note on variables: 
If we want variables to count as values, we would have to change our definition to substitution accordingly.

\subsection{Call-by-Value STLC}
\begin{align*}
\inferrule{{\bf \Gamma},x:{\bf \tau} \vdash {\bf e} : {\bf \tau'}}
{{\bf \Gamma} \vdash_v \elam x {\bf \tau} {\bf e} :{\bf \tau} \to {\bf \tau'}}
\quad
\inferrule{{\bf \Gamma} \vdash {\bf e} : {\bf \tau}\to {\bf \tau'} \quad {\bf \Gamma} \vdash {\bf e'} : {\bf \tau}}
{{\bf \Gamma} \vdash {\bf e}~{\bf e'} :{\bf \tau'}}
\quad
\inferrule{{\bf \Gamma},x:{\bf \tau} \vdash {\bf e} : {\bf \tau'} \quad {\bf \Gamma} \vdash_v {\bf v} : {\bf \tau}}
{{\bf \Gamma} \vdash (\elam x {\bf \tau} {\bf e})~{\bf v} \sqsupseteq \sqsubseteq {\bf e}[{\bf v}/x] :{\bf \tau'}}
\end{align*}


\subsection{Call-by-Value Products}
The product type demonstrates a subtle point of this approach. We cannot use one pair constructor as both
a value and an expression constructor, so we need to add one of each and then relate them.
\begin{align*}
\inferrule{{\bf \Gamma} \vdash {\bf e_1} : {\bf \tau_1} \quad {\bf \Gamma} \vdash {\bf e_2} : {\bf \tau_2}}
{{\bf \Gamma} \vdash \epair {{\bf e_1}} {{\bf e_2}} :{\bf \tau_1} \times {\bf \tau_2}}
\quad
\inferrule{{\bf \Gamma} \vdash {\bf e} : {\bf \tau_1} \times {\bf \tau_2}}
{{\bf \Gamma} \vdash {\bf e}.1 :{\bf \tau_1}}
\quad
\inferrule{{\bf \Gamma} \vdash {\bf e} : {\bf \tau_1} \times {\bf \tau_2}}
{{\bf \Gamma} \vdash {\bf e}.2 :{\bf \tau_2}}\\
\inferrule{{\bf \Gamma} \vdash_v {\bf v_1}  : {\bf \tau_1} \quad {\bf \Gamma} \vdash_v {\bf v_2}  : {\bf \tau_2}}
{{\bf \Gamma} \vdash_v \epair {{\bf v_1} } {{\bf v_2} }_v :{\bf \tau_1} \times {\bf \tau_2}}
\quad
\inferrule{{\bf \Gamma} \vdash_v {\bf v_1}  : {\bf \tau_1} \quad {\bf \Gamma} \vdash_v {\bf v_2}  : {\bf \tau_2}}
{{\bf \Gamma} \vdash \epair {{\bf v_1} } {{\bf v_2} }_v \sqsupseteq \sqsubseteq \epair {{\bf v_1} } {{\bf v_2} }:{\bf \tau_1} \times {\bf \tau_2}}
\\
\inferrule{{\bf \Gamma} \vdash_v {\bf v_1}  : {\bf \tau_1} \quad {\bf \Gamma} \vdash_v {\bf v_2}  : {\bf \tau_2}}
{{\bf \Gamma} \vdash \epair {{\bf v_1} } {{\bf v_2} }_v .1 \sqsupseteq \sqsubseteq {\bf v_1} :{\bf \tau_1}}
\quad
\inferrule{{\bf \Gamma} \vdash_v {\bf v_1}  : {\bf \tau_1} \quad {\bf \Gamma} \vdash_v {\bf v_2}  : {\bf \tau_2}}
{{\bf \Gamma} \vdash \epair {{\bf v_1} } {{\bf v_2} }_v .2 \sqsupseteq \sqsubseteq {\bf v_2} :{\bf \tau_2}}
\end{align*}

\section{Evaluation Contexts}
To permit effects to be evaluated in the middle of expressions, we need a notion of evaluation context.
We add a sort $EC(\Gamma,\tau, \tau')$ of evaluation contexts, writing the judgment as $\Gamma \vdash E : \tau \rightsquigarrow \tau'$,
and define the base language of evaluation contexts as follows:
\begin{align*}
\inferrule{{\bf \Gamma} \vdash {\bf \tau}}
{{\bf \Gamma} \vdash [\cdot] : {\bf \tau} \rightsquigarrow {\bf \tau}}
\quad
\inferrule{{\bf \Gamma} \vdash {\bf E} : {\bf \tau} \rightsquigarrow {\bf \tau'}
			\quad {\bf \Gamma} \vdash {\bf e} : {\bf \tau} }
{{\bf \Gamma} \vdash {\bf E}[{\bf e}] : {\bf \tau'}}
\quad
\inferrule{{\bf \Gamma} \vdash {\bf e} : {\bf \tau} }
{{\bf \Gamma} \vdash [\cdot][{\bf e}] \sqsupseteq \sqsubseteq {\bf e} : {\bf \tau}}
\end{align*}

We then need to extend our existing languages to describe their evaluation contexts.
Like the product expression/value split, we will technically have a new constructor for each evaluation context.
However, we abuse notation here since it should be clear which we are using.
\subsection{STLC Extension}
\begin{align*}
\inferrule{{\bf \Gamma} \vdash {\bf E} : {\bf \tau_s} \rightsquigarrow {\bf \tau}\to {\bf \tau'} \quad {\bf \Gamma} \vdash {\bf e} : {\bf \tau}}
{{\bf \Gamma} \vdash {\bf E}~{\bf e} : {\bf \tau_s} \rightsquigarrow {\bf \tau'}}
\quad
\inferrule{{\bf \Gamma} \vdash {\bf E} : {\bf \tau_s} \rightsquigarrow {\bf \tau}\to {\bf \tau'} \quad {\bf \Gamma} \vdash {\bf e'} : {\bf \tau}
			\quad {\bf \Gamma} \vdash {\bf e} : {\bf \tau_s} }
{{\bf \Gamma} \vdash ({\bf E}~{\bf e'})[{\bf e}] \sqsupseteq \sqsubseteq {\bf E}[{\bf e}]~{\bf e'} : {\bf \tau'}}\\
\inferrule{{\bf \Gamma} \vdash_v {\bf v} : {\bf \tau}\to {\bf \tau'} \quad {\bf \Gamma} \vdash {\bf e} :  {\bf \tau_s} \rightsquigarrow {\bf \tau}}
{{\bf \Gamma} \vdash {\bf v}~{\bf E} : {\bf \tau_s} \rightsquigarrow {\bf \tau'}}
\quad
\inferrule{{\bf \Gamma} \vdash {\bf E} : {\bf \tau_s} \rightsquigarrow {\bf \tau} \quad {\bf \Gamma} \vdash_v {\bf v} : {\bf \tau}\to {\bf \tau'}
			\quad {\bf \Gamma} \vdash {\bf e} : {\bf \tau_s} }
{{\bf \Gamma} \vdash ({\bf v}~{\bf E})[{\bf e}] \sqsupseteq \sqsubseteq {\bf v}~{\bf E}[{\bf e}] : {\bf \tau'}}
\end{align*}

\subsection{Let-bindings}

\newcommand{\elet}[4]{\lit{let}~ {#1}:{#2}:={#3}~\lit{in}~{#4}}
\begin{align*}
  \inferrule{{\bf\Gamma} \vdash {\bf e_1} : {\bf \tau} \quad
    {\bf\Gamma} \vdash {\bf \tau'} \quad
    {\bf\Gamma},x:{\bf \tau} \vdash {\bf e_2} : {\bf \tau'}}
    {{\bf\Gamma} \vdash \elet x {\bf \tau} {\bf e_1} {\bf e_2} : {\bf \tau'}}
  \quad  
  \inferrule{{\bf\Gamma} \vdash_v {\bf v_1} : {\bf \tau} \quad
    {\bf\Gamma} \vdash {\bf \tau'} \quad
    {\bf\Gamma},x:{\bf \tau} \vdash {\bf e_2} : {\bf \tau'}}
  {{\bf\Gamma} \vdash \elet x {\bf \tau} {\bf v_1} {\bf e_2}
    \equiv
        {\bf e_2}[{\bf v_1}/x]: {\bf \tau'}}
  \quad\\
  \inferrule{{\bf\Gamma} \vdash {\bf E_1} : {\bf\tau_s} \rightsquigarrow {\bf \tau} \quad
    {\bf\Gamma} \vdash {\bf \tau'} \quad
    {\bf\Gamma},x:{\bf \tau} \vdash {\bf e_2} : {\bf \tau'}}
            {{\bf\Gamma} \vdash \elet x {\bf \tau} {\bf E_1} {\bf e_2}
              : {\bf\tau_s}\rightsquigarrow{\bf \tau'}}
  \quad\\
  \inferrule{{\bf\Gamma} \vdash {\bf E_1} : {\bf\tau_s} \rightsquigarrow {\bf \tau} \quad
    {\bf\Gamma} \vdash {\bf \tau'} \quad
    {\bf\Gamma},x:{\bf \tau} \vdash {\bf e_2} : {\bf \tau'}}
            {{\bf\Gamma} \vdash (\elet x {\bf \tau} {\bf E_1} {\bf e_2})[{\bf e}]
              \equiv
              \elet x {\bf \tau} {{\bf E_1}[{\bf e}]} {\bf e_2}
              : {\bf\tau_s}\rightsquigarrow{\bf \tau'}}\\
  \inferrule{{\bf\Gamma} \vdash {\bf e} : {\bf \tau} \quad
    {\bf\Gamma} \vdash {\bf E} : {\bf \tau} \rightsquigarrow{\bf \tau'}}
  {{\bf\Gamma} \vdash \elet x {\bf \tau} {\bf e} {{\bf E}[x]}
    \equiv
        {\bf E}[{\bf e}]: {\bf \tau'}}
\end{align*}

\section{Effectful Operations}
We want to be able to identify expressions that represent an effect ready to be performed,
so we introduce a new sort, $Ef(\Gamma,\tau)$ for such expressions
and declare $Ef(\Gamma,\tau) \sqsupseteq Exp(\Gamma,\tau)$.
We write $\Gamma \vdash_{Ef} e : \tau$ to represent $e : Ef(\Gamma,\tau)$.

\section{Mutable State}
We show here an axiomatic semantics for a global memory, assuming a semantics for natural numbers.
We add a new sort for stores, written $Store({\bf \Gamma})$ with judgment notation ${\bf \Gamma}\vdash_S {\bf S}$,
and the following rules:
\begin{align*}
\inferrule{\vdash {\bf \Gamma}}{{\bf \Gamma}\vdash_S \emptyset}\quad
\inferrule{{\bf \Gamma}\vdash_S {\bf S}
\quad {\bf \Gamma}\vdash_v {\bf v_1} : \mathbb N
\quad {\bf \Gamma}\vdash_v {\bf v_2} : \mathbb N}
{{\bf \Gamma}\vdash_S {\bf S}({\bf v_2}:= {\bf v_1})}\quad
\inferrule{{\bf \Gamma}\vdash_S {\bf S}
\quad {\bf \Gamma}\vdash_v {\bf v} : \mathbb N}
{{\bf \Gamma}\vdash {\bf S}.{\bf v} : \mathbb N}\\\quad
\inferrule{{\bf \Gamma}\vdash_S {\bf S}
\quad {\bf \Gamma}\vdash_v {\bf v_1} : \mathbb N
\quad {\bf \Gamma}\vdash_v {\bf v_2} : \mathbb N}
{{\bf \Gamma}\vdash {\bf S}({\bf v_2}:= {\bf v_1}).{\bf v_2}
\equiv
{\bf v_1} : \mathbb N}\quad
\inferrule{ {\bf \Gamma}\vdash_v {\bf v_1} : \mathbb N
\quad {\bf \Gamma}\vdash_v {\bf v_2} : \mathbb N}
{{\bf \Gamma}\vdash \emptyset.{\bf v_2}
\sqsupseteq
{\bf v_1} : \mathbb N}\\
\inferrule{{\bf \Gamma}\vdash_S {\bf S}
\quad {\bf \Gamma}\vdash_v {\bf v_1} : \mathbb N
\quad {\bf \Gamma}\vdash_v {\bf v_2} : \mathbb N
\quad {\bf \Gamma}\vdash_v {\bf v_3} : \mathbb N
\quad {\bf v_2} \neq {\bf v_3}}
{{\bf \Gamma}\vdash {\bf S}({\bf v_2}:= {\bf v_1}).{\bf v_3}
\equiv
{\bf S}.{\bf v_3} : \mathbb N}
\end{align*}


We also add a new sort for configurations, written
$CFG({\bf\Gamma},{\bf\tau})$ with judgment notation ${\bf \Gamma}\vdash_C C : {\bf \tau}$, and the following rules:

\begin{align*}
\inferrule{\cdot \vdash_v {\bf S} : \texttt{list } \mathbb N
\quad {\bf \Gamma} \vdash {\bf e} : {\bf\tau}}
{{\bf\Gamma}\vdash_C{\bf S}\triangleright {\bf e} :{\bf\tau}}
\quad
\inferrule{
{\bf\Gamma}\vdash{\bf e_1} : \mathbb N \quad
{\bf\Gamma}\vdash{\bf e_2} : \mathbb N \quad}
{{\bf\Gamma}\vdash\texttt{write }{\bf e_1}\texttt{ to }{\bf e_2} : \tunit}
\quad
\inferrule{
{\bf\Gamma}\vdash{\bf E} : {\bf \tau_s}\rightsquigarrow\mathbb N \quad
{\bf\Gamma}\vdash{\bf e_2} : \mathbb N}
{{\bf\Gamma}\vdash\texttt{write }{\bf E}\texttt{ to }{\bf e_2} : {\bf \tau_s}\rightsquigarrow \tunit}
\quad\\
\inferrule{
{\bf\Gamma}\vdash_v{\bf v} : \mathbb N \quad
{\bf\Gamma}\vdash{\bf E} : {\bf \tau_s}\rightsquigarrow\mathbb N}
          {{\bf\Gamma}\vdash\texttt{write }{\bf v}\texttt{ to }{\bf E}
            : {\bf \tau_s}\rightsquigarrow\tunit}
\quad
\inferrule{
{\bf\Gamma}\vdash{\bf E} : {\bf \tau_s}\rightsquigarrow\mathbb N \quad
{\bf\Gamma}\vdash{\bf e_2} : \mathbb N \quad
{\bf\Gamma}\vdash{\bf e'} : {\bf\tau_s}}
{{\bf\Gamma}\vdash(\texttt{write }{\bf E}\texttt{ to }{\bf e_2})[{\bf e'}]
\equiv
\texttt{write }{\bf E}[{\bf e'}]\texttt{ to }{\bf e_2} :\tunit}
\quad\\
\inferrule{
{\bf\Gamma}\vdash_v{\bf v} : \mathbb N \quad
{\bf\Gamma}\vdash{\bf E} : {\bf \tau_s}\rightsquigarrow\mathbb N \quad
{\bf\Gamma}\vdash{\bf e'} : {\bf\tau_s}}
{{\bf\Gamma}\vdash(\texttt{write }{\bf v}\texttt{ to }{\bf E})[{\bf e'}] 
\equiv
\texttt{write }{\bf v}\texttt{ to }{\bf E}[{\bf e'}]:\tunit}\quad\\
\inferrule{
{\bf\Gamma}\vdash_v{\bf v_1} : \mathbb N \quad
{\bf\Gamma}\vdash_v{\bf v_2} : \mathbb N \quad}
{{\bf\Gamma}\vdash_{Ef}\texttt{write}_{Ef}~{\bf v_1}\texttt{ to }{\bf v_2} : \tunit}
\quad
\inferrule{
{\bf\Gamma}\vdash_v{\bf v_1} : \mathbb N \quad
{\bf\Gamma}\vdash_v{\bf v_2} : \mathbb N \quad}
          {{\bf\Gamma}\vdash\texttt{write}_{Ef}~{\bf v_1}\texttt{ to }{\bf v_2}
            \equiv\texttt{write }{\bf v_1}\texttt{ to }{\bf v_2} : \tunit}
\quad\\
\inferrule{
{\bf\Gamma}\vdash{\bf e} : \mathbb N}
{{\bf\Gamma}\vdash\texttt{read }{\bf e} : \mathbb N}
\quad
\inferrule{
  {\bf\Gamma}\vdash{\bf E} : {\bf \tau_s} \rightsquigarrow \mathbb N}
{{\bf\Gamma}\vdash\texttt{read }{\bf E} : {\bf \tau_s} \rightsquigarrow \mathbb N}
\quad
\inferrule{
{\bf\Gamma}\vdash{\bf E} : {\bf \tau_s} \rightsquigarrow \mathbb N
\quad {\bf\Gamma}\vdash {\bf e'} : {\bf \tau_s}}
{{\bf\Gamma}\vdash(\texttt{read }{\bf E})[{\bf e'}] 
\equiv
\texttt{read }({\bf E}[{\bf e'}]): \mathbb N}
\quad\\
\inferrule{
{\bf\Gamma}\vdash_v{\bf v} : \mathbb N}
{{\bf\Gamma}\vdash_{Ef}\texttt{read}_{Ef}~{\bf v} : \mathbb N}
\quad
\inferrule{
{\bf\Gamma}\vdash_v{\bf v} : \mathbb N}
          {{\bf\Gamma}\vdash\texttt{read }{\bf v}
            \equiv\texttt{read}_{Ef}~{\bf v}: \mathbb N}
\quad\\
\inferrule{\vdash_S {\bf S}
\quad {\bf \Gamma} \vdash_v {\bf v} : \mathbb N}
{{\bf\Gamma}\vdash_C{\bf S}\triangleright \elet x {\mathbb N} {\texttt{read}_{Ef}~{\bf v}} e
\equiv
{\bf S} \triangleright e[{\bf S}.{\bf v}/x] :{\bf\tau}}\quad\\
\inferrule{\vdash_S {\bf S}\quad
{\bf\Gamma}\vdash_v{\bf v_1} : \mathbb N \quad
{\bf\Gamma}\vdash_v{\bf v_2} : \mathbb N \quad
{\bf\Gamma}\vdash{\bf e_3} : {\bf \tau}\quad
{\bf\Gamma}\vdash{\bf e'} : {\bf\tau_s}}
          {{\bf\Gamma}\vdash{\bf S}\triangleright
            \elet x \tunit {\texttt{write}_{Ef}~{\bf v_1}\texttt{ to }{\bf v_2}} e
\equiv
{\bf S}({\bf v_2}:={\bf v_1})\triangleright{\bf e}[\eunit/x]:{\bf \tau}}
\end{align*}


\section{Exceptions}
Exceptions need to trace outwards through evaluation contexts until they hit a handler.
To capture this behavior, we will add handlers, but not designate them as evaluation contexts.
We assume the boolean language (not written here) for demonstration purposes.
\newcommand{\handleexn}[3]{\texttt{handle }{#1}\texttt{ catch }{#2}.{#3}}
\newcommand{\throwexn}[1]{\texttt{throw }{#1}}
\begin{align*}
\inferrule{{\bf\Gamma}\vdash {\bf e} : \mathbb B\quad {\bf\Gamma}\vdash {\bf\tau}}
{{\bf \Gamma}\vdash\throwexn {\bf e} : {\bf\tau}}\quad
\inferrule{{\bf\Gamma}\vdash_v {\bf v} : \mathbb B\quad {\bf\Gamma}\vdash {\bf\tau}}
{{\bf \Gamma}\vdash_{Ef}\lit{throw}_{Ef}~ {\bf v} : {\bf\tau}}\quad
\inferrule{{\bf\Gamma}\vdash_v {\bf v} : \mathbb B\quad {\bf\Gamma}\vdash {\bf\tau}}
{{\bf \Gamma}\vdash\lit{throw}_{Ef}~ {\bf v}\equiv\throwexn {\bf v} : {\bf\tau}}\quad\\
\inferrule{{\bf\Gamma}\vdash {\bf e} : {\bf\tau}\quad{\bf\Gamma},x:\mathbb{B}\vdash {\bf e'} : {\bf\tau}}
{{\bf\Gamma}\vdash \handleexn {\bf e} x {\bf e'} : {\bf\tau}}
\quad
\inferrule{{\bf\Gamma}\vdash_v {\bf v} : \mathbb B\quad
  {\bf\Gamma},x:{\bf\tau}\vdash {\bf e} : {\bf\tau'}\quad
  {\bf\Gamma},y:\mathbb{B}\vdash {\bf e'} : {\bf\tau'}}
{{\bf\Gamma}\vdash \handleexn {\elet x {\bf \tau} {\lit{throw}_{Ef}~ {\bf v}} {\bf e}} y {\bf e'}
	\equiv {\bf e'}[{\bf v}/y] : {\bf\tau'}}\\
\inferrule{{\bf\Gamma}\vdash_v {\bf v} : {\bf \tau}\quad{\bf\Gamma},x:\mathbb{B}\vdash {\bf e'} : {\bf\tau}}
{{\bf\Gamma}\vdash \handleexn {\bf v} x {\bf e'}
	\equiv{\bf v} : {\bf\tau}}
	\quad
\inferrule{{\bf\Gamma}\vdash {\bf E} : {\bf \tau_s} \rightsquigarrow \mathbb B\quad {\bf\Gamma}\vdash {\bf\tau}}
{{\bf \Gamma}\vdash\throwexn {\bf E} : {\bf \tau_s} \rightsquigarrow{\bf\tau}}\quad
\inferrule{{\bf\Gamma}\vdash {\bf E} : {\bf \tau_s} \rightsquigarrow \mathbb B
\quad{\bf\Gamma}\vdash{\bf e}:{\bf\tau_s}\quad {\bf\Gamma}\vdash {\bf\tau}}
{{\bf \Gamma}\vdash(\throwexn {\bf E})[{\bf e}]
  \equiv \throwexn {({\bf E}[{\bf e}])}:{\bf\tau}}\quad\\
\inferrule{{\bf\Gamma}\vdash_{Ef} {\bf e_f} : {\bf \tau}\quad
  {\bf\Gamma},x:{\bf\tau}\vdash {\bf e} : {\bf\tau'}\quad
  {\bf\Gamma},y:\mathbb B\vdash {\bf e'} : {\bf\tau'}
  \quad \neg{\lit{is\_throw}(e_f)}}
{{\bf\Gamma}\vdash \handleexn {\elet x {\bf \tau} {\bf e_f} {\bf e}} y {\bf e'}
	\equiv \elet x {\bf \tau} {\bf e_f} {\handleexn {\bf e} y {\bf e'}} : {\bf\tau'}}\\
\end{align*}


Note that we have not yet provided an implementation for $\neg{\lit{is\_throw}(e_f)}$.
There are a couple approaches here.
The most straightforward would be to define this operation pointwise
over all effects, but this fails modularity like the prior versions of
these languages.

A modular approach involves a sort of effect tags, with each effect term related to a tag
and an inequality operation on tags.
That said, this would require a good number of rules to formalize.
It would be more pleasant if we could directly write the
proposition we want in Coq and then import it into our framework.

An additional note on global effects:
If we wanted to add, for example, an additional global register file to our mutable state
language, we would run into an issue of what comprises a top-level configuration.
There are two immediate approaches: first, we could unify configurations
and expressions, creating a language with local state,
and by convention only write programs with one state at the top level.
Then we could add analogues of the exception handler pass-through rule to our
mutable state languages.

Alternately, we could standardize the idea of a configuration and
add the ability to extend the contents of a configuration, e.g.
by giving its state component map-like properties with an extensible set of keys.

\end{document}







