\documentclass{article}
\usepackage{mathpartir}
\usepackage{graphicx}
\usepackage{cancel}
\usepackage{amssymb}
\usepackage{amsmath}

\newcommand{\namedrule}[3]{\inferrule{#1}{#2}\ \text{({\sc #3})}}
\newcommand{\rulename}[1]{\textsc{#1}}
\newcommand{\lit}[1]{\textsf{#1}}
\newcommand{\FV}{\mathit{FV}}
\newcommand{\dom}{\mathop{\mathrm{dom}}}
\newcommand{\var}[1]{\mathit{#1}}

\newcommand{\decl}[2]{#1{:}#2}
\newcommand{\rdecl}[2]{#1\,{:}\,#2}
\newcommand{\rbind}[2]{#1 = #2}
\newcommand{\bind}[2]{#1.\, #2}
\newcommand{\tbind}[3]{\bind{\decl{#1}{#2}}{#3}}

\newcommand{\step}[2]{#1 \longrightarrow #2}
\newcommand{\stepstar}[2]{#1 \longrightarrow^* #2}

\newcommand{\etrue}{\lit{true}}
\newcommand{\efalse}{\lit{false}}
\newcommand{\eif}[4]{\lit{if}_{#1}\,#2\,\lit{then}\,#3\,\lit{else}\,#4}
\newcommand{\enot}{\lit{not}}
\newcommand{\eand}{\lit{and}}
\newcommand{\eor}{\lit{or}}
\newcommand{\ezero}{\lit{zero}}
\newcommand{\esucc}[1]{\lit{succ}\,#1}
\newcommand{\enil}{\lit{nil}}
\newcommand{\econs}{\lit{cons}}
\newcommand{\eleaf}{\lit{leaf}}
\newcommand{\enode}{\lit{node}}
\newcommand{\erec}[5]{\kwd{rec}(#1,\, #2,\, \tbind{#3}{#4}{#5})}
\newcommand{\eapp}[2]{#1\ #2}
\newcommand{\eApp}[2]{#1\,[#2]}
\newcommand{\eunit}{\langle \rangle}
\newcommand{\epair}[2]{\langle #1, #2 \rangle}
\newcommand{\efst}[1]{\lit{fst}\,#1}
\newcommand{\esnd}[1]{\lit{snd}\,#1}
\newcommand{\einl}[1]{\lit{inl}\,#1}
\newcommand{\einr}[1]{\lit{inr}\,#1}
\newcommand{\ecase}[5]{\lit{case}\,#1\,\lit{of}\,\einl{#2}\Rightarrow\,#3
  \mid\,\einr{#4}\Rightarrow\,#5}
\newcommand{\epackspaced}[5]{\lit{pack}\,\langle #1,#2 \rangle #3\lit{as}\:{\texist #4 #5}}
\newcommand{\epack}[4]{\epackspaced #1 #2 {\,} #4}
\newcommand{\eunpack}[4]{\lit{unpack}\,\langle #2,#3 \rangle = #1\:\lit{in}\:#4}
%\newcommand{\elet}[3]{\lit{let}\,#1 = #2\,\lit{in}\,#3}

\newcommand{\eproj}[2]{#1.#2}
\newcommand{\eunroll}[1]{\kwd{unroll}\,#1}
\newcommand{\eannot}[2]{(#1 : #2)}
%\newcommand{\elam}[2]{\lambda \bind{#1}{#2}}
\newcommand{\elam}[3]{\lambda \tbind{#1}{#2}{#3}}
\newcommand{\eLam}[2]{\Lambda \bind{#1}{#2}}
\newcommand{\erecord}[1]{\{\, #1 \,\}}
\newcommand{\einj}[2]{[\, \rbind{#1}{#2} \,]}
%\newcommand{\ecase}[4]{\kwd{case}\,#1\,\{\,\einj{#2}{#3} \Rightarrow #4\,\}}
\newcommand{\enatcase}[4]{\kwd{natcase}\,#1\,\kwd{of}\,\{\,\lzero \Rightarrow #2,%
                                                 \lsucc\,#3 \Rightarrow #4\,\}}
\newcommand{\elistcase}[6]{\kwd{listcase}_#1\,#2\,%
                            \{\,\lnil \Rightarrow #3,%
                                \lcons(#4, #5) \Rightarrow #6\,\}}
\newcommand{\eroll}[1]{\lit{roll}\,#1}
%\newcommand{\efix}[2]{\kwd{fix}\,\bind{#1}{#2}}

\newcommand{\efix}[3]{\kwd{fix}\,\tbind{#1}{#2}{#3}}
\newcommand{\etroll}[2]{\lit{roll}_{#1}\,{#2}}
\newcommand{\etinj}[3]{\einj{#1}{#2}_{#3}}
\newcommand{\etcase}[3]{\kwd{case}_{#1}\,#2\,\{\,#3\,\}}
\newcommand{\casecase}[3]{\einj{#1}{#2} \Rightarrow #3}
\newcommand{\etcasen}[5]{\kwd{case}_{#1}\,#2\,\{\,\casecase{#3}{#4}{#5}\,\}}

% \newcommand{\steval}[2]{#1 > #2}
% \newcommand{\stret}[2]{#1 < #2}
% \newcommand{\stfail}[2]{#1 < \lit{fail}}

\newcommand{\tbool}{\lit{bool}}
\newcommand{\tnat}{\lit{nat}}
\newcommand{\tstr}{\lit{string}}
\newcommand{\tint}{\lit{int}}
\newcommand{\tnatlist}{\lit{natlist}}
\newcommand{\tlist}[1]{#1\,\lit{list}}
\newcommand{\ttree}[1]{#1\,\lit{tree}}
\newcommand{\tarrow}[2]{#1 \rightarrow #2}
\newcommand{\tunit}{\lit{unit}}
\newcommand{\tprod}[2]{#1 \times #2}
\newcommand{\tsum}[2]{#1 + #2}
\newcommand{\trecord}[1]{\{\, #1 \,\}}
\newcommand{\tvariant}[1]{[\, #1 \,]}
\newcommand{\tmu}[2]{\mu \bind{#1}{#2}}
\newcommand{\tforall}[2]{\forall \bind{#1}{#2}}
\newcommand{\texist}[2]{\exists \bind{#1}{#2}}


\newcommand{\cclam}[2]{\lambda \bind{({#1})}{#2}}

\begin{document}
\section{Interpretation of rules}
\[
\inferrule{ \Gamma_1 \vdash X_1~{\tt type} ~...~ \Gamma_i \vdash X_i~{\tt type}}{\Gamma \vdash c(X_1,...,X_i)~{\tt type}}
\equiv
{\tt term\_rule}~[\Gamma_1 : {\tt Ctx},...,\Gamma_i : {\tt Ctx},X_1 :{\tt Ty}~ \Gamma_1,...,X_i:{\tt Ty}~ \Gamma_i]~({\tt Ty}~ \Gamma) \]


\[\begin{array}{l}
\inferrule{ \Gamma_1 \vdash X_1~{\tt type} ~...~ \Gamma_i \vdash X_i~{\tt type}
 \quad \Gamma'_1 \vdash x_1 :\tau'_1 ~...~ \Gamma'_j \vdash x_j :\tau'_j}{\Gamma \vdash c(X_1,...,X_i,x_1,...,x_j) : \tau}
\\\equiv
{\tt term\_rule}~[\Gamma_1 : {\tt Ctx},...,\Gamma_i : {\tt Ctx},{\tt Ty}~ \Gamma_1,...,{\tt Ty}~ \Gamma_i,{\tt El}~ \Gamma'_1~\tau_1,...,{\tt El}~ \Gamma'_i~\tau_i]~({\tt El}~ \Gamma~ \tau)
\end{array}\]
\section{STLC Rules}
\begin{align*}
\inferrule{\Gamma,x:\tau \vdash e : \tau'}
{\Gamma \vdash \elam x \tau e :\tau \to \tau'}
\quad
\inferrule{\Gamma \vdash e : \tau\to \tau' \quad \Gamma \vdash e' : \tau}
{\Gamma \vdash e~e' :\tau'}
\quad
\inferrule{\Gamma,x:\tau \vdash e : \tau' \quad \Gamma \vdash e' : \tau}
{\Gamma \vdash (\elam x \tau e)~e' \sqsupseteq \sqsubseteq e[e'/x] :\tau'}
\end{align*}
\section{CC Rules}
TODO: 2 options: can close over delta or leave it open. Need tyvars for the former, so I'll avoid it for expedience.
\begin{align*}
\inferrule{\Delta;x_1:\tau_1...x_n:\tau_n \vdash e : \tau'}
{\Delta; \Gamma \vdash \cclam {x_1:\tau_1...x_n:\tau_n} e 
:(\tau_1...\tau_n) \to \tau'}
\quad
\\\inferrule{\Delta;\Gamma \vdash e : {(\tau_1...\tau_n) \to \tau'} 
\quad \Delta;\Gamma \vdash e'_1  : \tau ~...~ \Gamma \vdash e'_n  : \tau}
{\Delta;\Gamma \vdash e~(e'_1...e'_n) :\tau'}
\\\quad
\inferrule{\Delta;x_1:\tau_1...x_n:\tau_n \vdash e : \tau' 
\quad \Delta;\Gamma \vdash e'_1  : \tau ~...~ \Gamma \vdash e'_n  : \tau}
{\Delta; \Gamma \vdash (\cclam {x_1:\tau_1...x_n:\tau_n} e)~(e'_1...e'_n) 
	 \sqsupseteq \sqsubseteq e[e'_1/x_1,...,e'_n/x_n] :\tau'}
\end{align*}
We additionally add the standard rules for existentials, pairs, and the unit type (TODO: write out).
\section{Compiler}
We define our compiler as follows:
\[\begin{array}{lcl}
(\tau \to \tau')^+ &=&  \texist Y {\tprod{({(Y, \tau^+) \to \tau'^+})}Y}\\
(\Gamma \vdash \elam x \tau e : \tau \to \tau')^+ &=& 
	\epackspaced {envty(\Gamma^+)}
	{\epair {\cclam {y: envty(\Gamma^+), x : \tau^+} {e^+[y.i/i]}}{mkenv(size(\Gamma^+))}}{\\&&}
	Y {\tprod{({(Y, \tau^+) \to \tau'^+})}Y}\\
(e~e')^+ &=& \eunpack {e^+} Y p {p.1~ (p.2,e'^+)}\\
\\
mkenv(0) &=& \eunit\\
mkenv(n +1) &=& \epair {mkenv(n)} n\\
\\ 
envty(\cdot) &=& \tunit\\
envty(\Gamma, \tau) &=& \tprod {envty(\Gamma)} {\tau}
\end{array}\]

\subsection{Judgment-preserving compilation}
We proceed rule-by-rule. Consider an arbitrary substitution satisfying the premises of each rule in the target.
It suffices to show that the translation is well-typed.
\begin{itemize}
\item Function type:
Consider arbitrary closed, well-formed $\tau,\tau'$ in the target language.
We then have the following derivation:
\[
\inferrule{\inferrule{
\inferrule{\inferrule{Y \in Y}{Y \vdash Y} \quad {Y \vdash \tau}\quad{Y \vdash \tau'}}
{Y \vdash {({(Y, \tau) \to \tau'})}}
	 \quad \inferrule{Y \in Y}{Y \vdash Y}}
{Y \vdash \tprod{({(Y, \tau) \to \tau'})}Y}}
{\cdot \vdash \texist Y {\tprod{({(Y, \tau) \to \tau'})}Y}}
\]
\item Application:
Let $\tau_f = \tprod{({(Y, \tau) \to \tau'})}Y$.
\[
\inferrule{
	\cdot; \Gamma \vdash e : \texist Y {\tau_f}
	\quad \inferrule{\inferrule{\inferrule{ }{Y;\Gamma,p : \tau_f\vdash {p} : \tau_f}}
				{Y;\Gamma,p : \tau_f\vdash {p.1} : {(Y, \tau) \to \tau'}}
				\quad \inferrule{\inferrule{ }{Y;\Gamma,p : \tau_f\vdash {p} : \tau_f}}{Y;\Gamma,p : \tau_f\vdash {p.2} : Y}
				\quad \inferrule{Y;\Gamma\vdash {e'} : \tau}{Y;\Gamma,p : \tau_f\vdash {e'} : \tau}}
		{Y;\Gamma,p : \tau_f\vdash {p.1~ (p.2,e')} : \tau'}
	\quad \cdot \vdash \tau'}
{\cdot;\Gamma \vdash \eunpack {e} Y p {p.1~ (p.2,e')} : \tau'}
\] 
\item Beta-reduction: We need to show the following:
\[
\inferrule{\Gamma,x:\tau \vdash e : \tau' \quad \Gamma \vdash e' : \tau}
{\begin{array}{lll}\Gamma \vdash &\eunpack {&\epackspaced {envty(\Gamma)}
	{\epair {\cclam {y: envty(\Gamma), x : \tau} {e[y.i/i]}}{mkenv(size(\Gamma))}}{\\&&}
	Y {\tprod{({(Y, \tau) \to \tau'})}Y}\\&} Y p {p.1~ (p.2,e')}
\\&\sqsupseteq \sqsubseteq e[e'/x] :\tau'
\end{array}}\]
We proceed by these steps:
\[\begin{array}{rl}
&\begin{array}{lll}\eunpack {&\epackspaced {envty(\Gamma)}
	{\epair {\cclam {y: envty(\Gamma), x : \tau} {e[y.i/i]}}{mkenv(size(\Gamma))}}{\\&}
	Y {\tprod{({(Y, \tau) \to \tau'})}Y}\\} Y p {p.1~ (p.2,e')}
\end{array}\\
\sqsupseteq \sqsubseteq& 
(p.1~ (p.2,e'))[envty(\Gamma)/Y, \epair {\cclam {y: envty(\Gamma), x : \tau} {e[y.i/i]}}{mkenv(size(\Gamma))}/p]\\
\sqsupseteq \sqsubseteq& 
((\cclam {y: envty(\Gamma), x : \tau} {e[y.i/i]})~ 
	(mkenv(size(\Gamma)),e'))\\
\sqsupseteq \sqsubseteq& 
	e[y.i/i][mkenv(size(\Gamma))/y, e'/x]\\
\sqsupseteq \sqsubseteq& 
	e[e'/x]\\
\end{array}\]
\end{itemize}
\end{document}







